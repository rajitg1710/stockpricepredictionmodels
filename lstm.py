# -*- coding: utf-8 -*-
"""LSTM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17Avl0lBFhegDdD_zniDdPY6IWdb9ycm2
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
import yfinance as yf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam
import warnings
warnings.filterwarnings('ignore')

# 1. Data Collection
print("Fetching MSFT stock data...")
msft = yf.download('MSFT', start='2015-01-01', end='2019-01-10')
print(f"Data shape: {msft.shape}")
print(f"Date range: {msft.index[0]} to {msft.index[-1]}")

# Display basic info about the dataset
print("\nDataset Info:")
print(msft.head())
print(f"\nMissing values: {msft.isnull().sum().sum()}")

# 2. Data Preprocessing
# Extract closing prices
data = msft['Close'].values.reshape(-1, 1)
dates = msft.index

# Split data: 2015-2018 for training, first day of 2019 for prediction
train_size = len(data) - 1  # All data except the last day (first day of 2019)
train_data = data[:train_size]
actual_next_day_price = data[train_size]  # This is what we want to predict

print(f"\nTraining data points: {len(train_data)}")
print(f"Last training price: ${train_data[-1][0]:.2f}")
print(f"Actual next day price (target): ${actual_next_day_price[0]:.2f}")

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_train_data = scaler.fit_transform(train_data)

# Create sequences for LSTM
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i, 0])
        y.append(data[i, 0])
    return np.array(X), np.array(y)

# Use 60 days of historical data to predict the next day
sequence_length = 60
X_train, y_train = create_sequences(scaled_train_data, sequence_length)

# Reshape for LSTM input (samples, time steps, features)
X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))

print(f"\nTraining sequences shape: {X_train.shape}")
print(f"Training targets shape: {y_train.shape}")

# 3. Build LSTM Model
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(sequence_length, 1)),
    Dropout(0.2),
    LSTM(50, return_sequences=True),
    Dropout(0.2),
    LSTM(50),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer=Adam(learning_rate=0.001), loss='mean_squared_error')
print("\nModel Architecture:")
model.summary()

# 4. Train the Model
print("\nTraining the model...")
history = model.fit(
    X_train, y_train,
    epochs=50,
    batch_size=32,
    validation_split=0.1,
    verbose=1,
    shuffle=False
)

# 5. Make Predictions on Training Data
train_predictions = model.predict(X_train)
train_predictions = scaler.inverse_transform(train_predictions)
actual_train = scaler.inverse_transform(y_train.reshape(-1, 1))

# Calculate training metrics
train_rmse = np.sqrt(mean_squared_error(actual_train, train_predictions))
train_mae = mean_absolute_error(actual_train, train_predictions)

print(f"\nTraining Metrics:")
print(f"RMSE: ${train_rmse:.2f}")
print(f"MAE: ${train_mae:.2f}")

# 6. Predict the Next Day (First Trading Day of 2019)
# Use the last 60 days of training data to predict
last_sequence = scaled_train_data[-sequence_length:].reshape(1, sequence_length, 1)
predicted_price_scaled = model.predict(last_sequence)
predicted_price = scaler.inverse_transform(predicted_price_scaled)[0][0]

print(f"\nPrediction Results:")
print(f"Predicted closing price for first trading day of 2019: ${predicted_price:.2f}")
print(f"Actual closing price for first trading day of 2019: ${actual_next_day_price[0]:.2f}")
print(f"Prediction error: ${abs(predicted_price - actual_next_day_price[0]):.2f}")
print(f"Percentage error: {abs(predicted_price - actual_next_day_price[0]) / actual_next_day_price[0] * 100:.2f}%")

# 7. Visualization
plt.figure(figsize=(15, 10))

# Plot 1: Training loss
plt.subplot(2, 2, 1)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss During Training')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

# Plot 2: Actual vs Predicted (last 200 days of training)
plt.subplot(2, 2, 2)
last_n_days = 200
train_dates = dates[sequence_length:train_size][-last_n_days:]
plt.plot(train_dates, actual_train[-last_n_days:], label='Actual', alpha=0.7)
plt.plot(train_dates, train_predictions[-last_n_days:], label='Predicted', alpha=0.7)
plt.title(f'Actual vs Predicted Prices (Last {last_n_days} Days)')
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend()
plt.xticks(rotation=45)

# Plot 3: Full price history with prediction
plt.subplot(2, 1, 2)
plt.plot(dates[:train_size], train_data, label='Historical Prices', alpha=0.7)
plt.plot(dates[train_size], actual_next_day_price, 'ro', markersize=8, label='Actual Next Day')
plt.plot(dates[train_size], predicted_price, 'go', markersize=8, label='Predicted Next Day')
plt.title('MSFT Stock Price: Historical Data and Next Day Prediction')
plt.xlabel('Date')
plt.ylabel('Price ($)')
plt.legend()
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

# 8. Model Performance Analysis
print("\n" + "="*60)
print("MODEL PERFORMANCE SUMMARY")
print("="*60)
print(f"Training Period: {dates[0].strftime('%Y-%m-%d')} to {dates[train_size-1].strftime('%Y-%m-%d')}")
print(f"Prediction Date: {dates[train_size].strftime('%Y-%m-%d')}")
print(f"Training Data Points: {len(train_data)}")
print(f"Sequence Length: {sequence_length} days")
print(f"Model Architecture: 3 LSTM layers (50 units each) + Dense layer")
print(f"Training RMSE: ${train_rmse:.2f}")
print(f"Training MAE: ${train_mae:.2f}")
print(f"Next Day Prediction: ${predicted_price:.2f}")
print(f"Next Day Actual: ${actual_next_day_price[0]:.2f}")
print(f"Prediction Accuracy: {100 - abs(predicted_price - actual_next_day_price[0]) / actual_next_day_price[0] * 100:.2f}%")
print("="*60)

